================================================================================
Forward Performance Test (TileLang calc_attn_dist)
================================================================================
Parameters: batch=1, heads=128, chunk=8192, seq=131072, dim=576, topk=2048
================================================================================
2026-01-08 16:03:22  [TileLang:tilelang.jit.kernel:INFO]: TileLang begins to compile kernel `main` with `out_idx=[-3, -2, -1]`
Skip performance test Production: #include <tl_templates/cuda/instruction/mma.h>
#include <math_constants.h>
#include <tl_templates/cuda/gemm.h>
#include <tl_templates/cuda/copy.h>
#include <tl_templates/cuda/reduce.h>
#include <tl_templates/cuda/ldsm.h>
#include <tl_templates/cuda/threadblock_swizzle.h>
#include <tl_templates/cuda/debug.h>
#ifdef ENABLE_BF16
#include <tl_templates/cuda/cuda_bf16_fallbacks.cuh>
#endif

extern "C" __global__ void main_kernel(const int* __restrict__ Indices, const bfloat16_t* __restrict__ K, float* __restrict__ L_out, float* __restrict__ M_out, float* __restrict__ QK_out, __grid_constant__ const CUtensorMap Q_desc, const int* __restrict__ q_start_index_s);
extern "C" __global__ void __launch_bounds__(256, 1) main_kernel(const int* __restrict__ Indices, const bfloat16_t* __restrict__ K, float* __restrict__ L_out, float* __restrict__ M_out, float* __restrict__ QK_out, __grid_constant__ const CUtensorMap Q_desc, const int* __restrict__ q_start_index_s) {
  extern __shared__ __align__(1024) uchar buf_dyn_shmem[];
  __shared__ uint64_t bar_k_1_free_mem[1];
  auto bar_k_1_free = reinterpret_cast<Barrier*>(bar_k_1_free_mem);
  __shared__ uint64_t bar_k_0_free_mem[1];
  auto bar_k_0_free = reinterpret_cast<Barrier*>(bar_k_0_free_mem);
  __shared__ uint64_t bar_k_1_ready_mem[1];
  auto bar_k_1_ready = reinterpret_cast<Barrier*>(bar_k_1_ready_mem);
  __shared__ uint64_t bar_k_0_ready_mem[1];
  auto bar_k_0_ready = reinterpret_cast<Barrier*>(bar_k_0_ready_mem);
  __shared__ uint64_t bar_q_mem[1];
  auto bar_q = reinterpret_cast<Barrier*>(bar_q_mem);
  float sumexp[4];
  float m_i[4];
  __shared__ signed char is_k_valid_0[64];
  float acc_s[32];
  float m_i_prev[4];
  float sumexp_i[4];
  __shared__ signed char is_k_valid_1[64];
  int indices_local[1];
  bfloat16_t A_local[16];
  bfloat16_t B_local[16];
  bfloat16_t A_local_1[16];
  bfloat16_t B_local_1[16];
  bfloat16_t A_local_2[16];
  bfloat16_t B_local_2[16];
  bfloat16_t A_local_3[16];
  bfloat16_t B_local_3[16];
  bfloat16_t A_local_4[16];
  bfloat16_t B_local_4[16];
  bfloat16_t A_local_5[16];
  bfloat16_t B_local_5[16];
  if (tl::tl_shuffle_elect<0>()) {
    tl::prefetch_tma_descriptor(Q_desc);
  }
  if (tl::tl_shuffle_elect<0>()) {
    bar_k_1_free[0].init(128);
    bar_k_0_free[0].init(128);
    bar_k_1_ready[0].init(128);
    bar_k_0_ready[0].init(128);
    bar_q[0].init(256);
  }
  __syncthreads();
  int q_i = ((((int)blockIdx.x) >> 1) + q_start_index_s[0]);
  if (((int)threadIdx.x) == 0) {
    bar_q[0].expect_transaction(32768);
    tl::fence_proxy_async();
    tl::tma_load(Q_desc, bar_q[0], (&(((bfloat16_t*)buf_dyn_shmem)[0])), 0, ((((int)blockIdx.x) & 1) * 64), (((int)blockIdx.x) >> 1), 0);
    tl::tma_load(Q_desc, bar_q[0], (&(((bfloat16_t*)buf_dyn_shmem)[4096])), 64, ((((int)blockIdx.x) & 1) * 64), (((int)blockIdx.x) >> 1), 0);
    tl::tma_load(Q_desc, bar_q[0], (&(((bfloat16_t*)buf_dyn_shmem)[8192])), 128, ((((int)blockIdx.x) & 1) * 64), (((int)blockIdx.x) >> 1), 0);
    tl::tma_load(Q_desc, bar_q[0], (&(((bfloat16_t*)buf_dyn_shmem)[12288])), 192, ((((int)blockIdx.x) & 1) * 64), (((int)blockIdx.x) >> 1), 0);
    bar_q[0].expect_transaction(32768);
    tl::fence_proxy_async();
    tl::tma_load(Q_desc, bar_q[0], (&(((bfloat16_t*)buf_dyn_shmem)[16384])), 256, ((((int)blockIdx.x) & 1) * 64), (((int)blockIdx.x) >> 1), 0);
    tl::tma_load(Q_desc, bar_q[0], (&(((bfloat16_t*)buf_dyn_shmem)[20480])), 320, ((((int)blockIdx.x) & 1) * 64), (((int)blockIdx.x) >> 1), 0);
    tl::tma_load(Q_desc, bar_q[0], (&(((bfloat16_t*)buf_dyn_shmem)[24576])), 384, ((((int)blockIdx.x) & 1) * 64), (((int)blockIdx.x) >> 1), 0);
    tl::tma_load(Q_desc, bar_q[0], (&(((bfloat16_t*)buf_dyn_shmem)[28672])), 448, ((((int)blockIdx.x) & 1) * 64), (((int)blockIdx.x) >> 1), 0);
    bar_q[0].expect_transaction(8192);
    tl::fence_proxy_async();
    tl::tma_load(Q_desc, bar_q[0], (&(((bfloat16_t*)buf_dyn_shmem)[32768])), 512, ((((int)blockIdx.x) & 1) * 64), (((int)blockIdx.x) >> 1), 0);
  }
  bar_q[0].arrive();
  __syncthreads();
  if (((int)threadIdx.x) < 128) {
    tl::warpgroup_reg_alloc<240>();
    #pragma unroll
    for (int i = 0; i < 4; ++i) {
      sumexp[i] = 0x0p+0f/*0.000000e+00*/;
    }
    #pragma unroll
    for (int i_1 = 0; i_1 < 4; ++i_1) {
      m_i[i_1] = -0x1p+30f/*-1.073742e+09*/;
    }
    bar_q[0].wait(0);
    for (int i_i = 0; i_i < 16; ++i_i) {
      bar_k_0_ready[0].wait((i_i & 1));
      #pragma unroll
      for (int i_2 = 0; i_2 < 16; ++i_2) {
        for (int vec_s = 0; vec_s < 2; ++vec_s) {
          float condval;
          if (((bool)is_k_valid_0[(((((((int)threadIdx.x) >> 6) * 32) + (((i_2 & 7) >> 1) * 8)) + ((((int)threadIdx.x) & 3) * 2)) + vec_s)])) {
            condval = 0x0p+0f/*0.000000e+00*/;
          } else {
            condval = -CUDART_INF_F;
          }
          acc_s[((i_2 * 2) + vec_s)] = condval;
        }
      }
      for (int ki = 0; ki < 16; ++ki) {
        for (int i_3 = 0; i_3 < 2; ++i_3) {
          tl::ptx_ldmatrix_x4((&(((bfloat16_t*)buf_dyn_shmem)[((((((ki >> 2) * 4096) + (((((int)threadIdx.x) & 63) >> 5) * 2048)) + (i_3 * 1024)) + (((((int)threadIdx.x) & 15) >> 3) * 512)) + ((((((((int)threadIdx.x) & 15) * 64) + (((((((int)threadIdx.x) & 7) >> 2) + ((ki & 3) >> 1)) & 1) * 32)) + (((((((int)threadIdx.x) & 3) >> 1) + (ki & 1)) & 1) * 16)) + (((((((int)threadIdx.x) & 31) >> 4) + (((int)threadIdx.x) & 1)) & 1) * 8)) & 511))])) + 0, A_local + (i_3 * 8));
        }
        for (int i_4 = 0; i_4 < 2; ++i_4) {
          tl::ptx_ldmatrix_x4((&(((bfloat16_t*)buf_dyn_shmem)[((((((((((ki >> 2) * 4096) + ((((int)threadIdx.x) >> 6) * 2048)) + (i_4 * 1024)) + (((((int)threadIdx.x) & 31) >> 4) * 512)) + ((((int)threadIdx.x) & 7) * 64)) + (((((((int)threadIdx.x) & 7) >> 2) + ((ki & 3) >> 1)) & 1) * 32)) + (((((((int)threadIdx.x) & 3) >> 1) + (ki & 1)) & 1) * 16)) + (((((((int)threadIdx.x) & 15) >> 3) + (((int)threadIdx.x) & 1)) & 1) * 8)) + 86016)])) + 0, B_local + (i_4 * 8));
        }
        for (int i_5 = 0; i_5 < 2; ++i_5) {
          for (int j = 0; j < 2; ++j) {
            tl::mma_sync<tl::DataType::kBFloat16, tl::DataType::kBFloat16, tl::DataType::kFloat32, 16, 8, 16, false, true>(reinterpret_cast<float*>(acc_s + ((i_5 * 16) + (j * 8))), reinterpret_cast<const unsigned*>(A_local + (i_5 * 8)), reinterpret_cast<const unsigned*>(B_local + (j * 8)));
            tl::mma_sync<tl::DataType::kBFloat16, tl::DataType::kBFloat16, tl::DataType::kFloat32, 16, 8, 16, false, true>(reinterpret_cast<float*>(acc_s + (((i_5 * 16) + (j * 8)) + 4)), reinterpret_cast<const unsigned*>(A_local + (i_5 * 8)), reinterpret_cast<const unsigned*>(B_local + ((j * 8) + 4)));
          }
        }
      }
      tl::__sync_thread_partial<3, 128>();
      for (int ki_1 = 0; ki_1 < 16; ++ki_1) {
        for (int i_6 = 0; i_6 < 2; ++i_6) {
          tl::ptx_ldmatrix_x4((&(((bfloat16_t*)buf_dyn_shmem)[(((((((ki_1 >> 2) * 4096) + (((((int)threadIdx.x) & 63) >> 5) * 2048)) + (i_6 * 1024)) + (((((int)threadIdx.x) & 15) >> 3) * 512)) + ((((((((int)threadIdx.x) & 15) * 64) + (((((((int)threadIdx.x) & 7) >> 2) + ((ki_1 & 3) >> 1)) & 1) * 32)) + (((((((int)threadIdx.x) & 3) >> 1) + (ki_1 & 1)) & 1) * 16)) + (((((((int)threadIdx.x) & 31) >> 4) + (((int)threadIdx.x) & 1)) & 1) * 8)) & 511)) + 16384)])) + 0, A_local_1 + (i_6 * 8));
        }
        for (int i_7 = 0; i_7 < 2; ++i_7) {
          tl::ptx_ldmatrix_x4((&(((bfloat16_t*)buf_dyn_shmem)[((((((((((ki_1 >> 2) * 4096) + ((((int)threadIdx.x) >> 6) * 2048)) + (i_7 * 1024)) + (((((int)threadIdx.x) & 31) >> 4) * 512)) + ((((int)threadIdx.x) & 7) * 64)) + (((((((int)threadIdx.x) & 7) >> 2) + ((ki_1 & 3) >> 1)) & 1) * 32)) + (((((((int)threadIdx.x) & 3) >> 1) + (ki_1 & 1)) & 1) * 16)) + (((((((int)threadIdx.x) & 15) >> 3) + (((int)threadIdx.x) & 1)) & 1) * 8)) + 53248)])) + 0, B_local_1 + (i_7 * 8));
        }
        for (int i_8 = 0; i_8 < 2; ++i_8) {
          for (int j_1 = 0; j_1 < 2; ++j_1) {
            tl::mma_sync<tl::DataType::kBFloat16, tl::DataType::kBFloat16, tl::DataType::kFloat32, 16, 8, 16, false, true>(reinterpret_cast<float*>(acc_s + ((i_8 * 16) + (j_1 * 8))), reinterpret_cast<const unsigned*>(A_local_1 + (i_8 * 8)), reinterpret_cast<const unsigned*>(B_local_1 + (j_1 * 8)));
            tl::mma_sync<tl::DataType::kBFloat16, tl::DataType::kBFloat16, tl::DataType::kFloat32, 16, 8, 16, false, true>(reinterpret_cast<float*>(acc_s + (((i_8 * 16) + (j_1 * 8)) + 4)), reinterpret_cast<const unsigned*>(A_local_1 + (i_8 * 8)), reinterpret_cast<const unsigned*>(B_local_1 + ((j_1 * 8) + 4)));
          }
        }
      }
      for (int ki_2 = 0; ki_2 < 4; ++ki_2) {
        for (int i_9 = 0; i_9 < 2; ++i_9) {
          tl::ptx_ldmatrix_x4((&(((bfloat16_t*)buf_dyn_shmem)[(((((((((int)threadIdx.x) & 63) >> 5) * 2048) + (i_9 * 1024)) + (((((int)threadIdx.x) & 15) >> 3) * 512)) + ((((((((int)threadIdx.x) & 15) * 64) + (((((((int)threadIdx.x) & 7) >> 2) + (ki_2 >> 1)) & 1) * 32)) + (((((((int)threadIdx.x) & 3) >> 1) + (ki_2 & 1)) & 1) * 16)) + (((((((int)threadIdx.x) & 31) >> 4) + (((int)threadIdx.x) & 1)) & 1) * 8)) & 511)) + 32768)])) + 0, A_local_2 + (i_9 * 8));
        }
        for (int i_10 = 0; i_10 < 2; ++i_10) {
          tl::ptx_ldmatrix_x4((&(((bfloat16_t*)buf_dyn_shmem)[(((((((((((int)threadIdx.x) >> 6) * 2048) + (i_10 * 1024)) + (((((int)threadIdx.x) & 31) >> 4) * 512)) + ((((int)threadIdx.x) & 7) * 64)) + (((((((int)threadIdx.x) & 7) >> 2) + (ki_2 >> 1)) & 1) * 32)) + (((((((int)threadIdx.x) & 3) >> 1) + (ki_2 & 1)) & 1) * 16)) + (((((((int)threadIdx.x) & 15) >> 3) + (((int)threadIdx.x) & 1)) & 1) * 8)) + 102400)])) + 0, B_local_2 + (i_10 * 8));
        }
        for (int i_11 = 0; i_11 < 2; ++i_11) {
          for (int j_2 = 0; j_2 < 2; ++j_2) {
            tl::mma_sync<tl::DataType::kBFloat16, tl::DataType::kBFloat16, tl::DataType::kFloat32, 16, 8, 16, false, true>(reinterpret_cast<float*>(acc_s + ((i_11 * 16) + (j_2 * 8))), reinterpret_cast<const unsigned*>(A_local_2 + (i_11 * 8)), reinterpret_cast<const unsigned*>(B_local_2 + (j_2 * 8)));
            tl::mma_sync<tl::DataType::kBFloat16, tl::DataType::kBFloat16, tl::DataType::kFloat32, 16, 8, 16, false, true>(reinterpret_cast<float*>(acc_s + (((i_11 * 16) + (j_2 * 8)) + 4)), reinterpret_cast<const unsigned*>(A_local_2 + (i_11 * 8)), reinterpret_cast<const unsigned*>(B_local_2 + ((j_2 * 8) + 4)));
          }
        }
      }
      tl::wait_wgmma<0>();
      #pragma unroll
      for (int i_12 = 0; i_12 < 16; ++i_12) {
        float2 __1;
          float2 v_ = *(float2*)(acc_s + (i_12 * 2));
          float2 v__1 = make_float2(0x1.ec709dbe8903ep-5f/*6.011229e-02*/, 0x1.ec709dbe8903ep-5f/*6.011229e-02*/);
          __1.x = (v_.x*v__1.x);
          __1.y = (v_.y*v__1.y);
        *(float2*)(QK_out + (((((((((((int64_t)((int)blockIdx.x)) * (int64_t)131072) + (((((int64_t)((int)threadIdx.x)) & (int64_t)63) >> (int64_t)5) * (int64_t)65536)) + ((((int64_t)i_12) >> (int64_t)3) * (int64_t)32768)) + ((((int64_t)i_12) & (int64_t)1) * (int64_t)16384)) + (((((int64_t)((int)threadIdx.x)) & (int64_t)31) >> (int64_t)2) * (int64_t)2048)) + (((int64_t)i_i) * (int64_t)128)) + ((((int64_t)((int)threadIdx.x)) >> (int64_t)6) * (int64_t)32)) + (((((int64_t)i_12) & (int64_t)7) >> (int64_t)1) * (int64_t)8)) + ((((int64_t)((int)threadIdx.x)) & (int64_t)3) * (int64_t)2))) = __1;
      }
      #pragma unroll
      for (int i_13 = 0; i_13 < 4; ++i_13) {
        m_i_prev[i_13] = m_i[i_13];
      }
      tl::__sync_thread_partial<3, 128>();
      #pragma unroll
      for (int i_14 = 0; i_14 < 4; ++i_14) {
        #pragma unroll
        for (int rv = 0; rv < 8; ++rv) {
          m_i[i_14] = max(m_i[i_14], acc_s[(((((i_14 >> 1) * 16) + ((rv & 3) * 4)) + ((i_14 & 1) * 2)) + (rv >> 2))]);
        }
        m_i[i_14] = tl::AllReduce<tl::MaxOp, 128, 64, 0, 128>::run_hopper(m_i[i_14], (&(((float*)buf_dyn_shmem)[55424])));
        m_i[i_14] = tl::AllReduce<tl::MaxOp, 4, 1, 0, 128>::run_hopper(m_i[i_14]);
      }
      #pragma unroll
      for (int i_15 = 0; i_15 < 4; ++i_15) {
        m_i[i_15] = max(m_i[i_15], m_i_prev[i_15]);
      }
      #pragma unroll
      for (int i_16 = 0; i_16 < 32; ++i_16) {
        acc_s[i_16] = exp2f(((acc_s[i_16] * 0x1.ec709dbe8903ep-5f/*6.011229e-02*/) - (m_i[(((i_16 >> 4) * 2) + ((i_16 & 3) >> 1))] * 0x1.ec709dbe8903ep-5f/*6.011229e-02*/)));
      }
      #pragma unroll
      for (int i_17 = 0; i_17 < 16; ++i_17) {
        for (int vec_s_1 = 0; vec_s_1 < 2; ++vec_s_1) {
          float condval_1;
          if (((bool)is_k_valid_0[(((((((int)threadIdx.x) >> 6) * 32) + (((i_17 & 7) >> 1) * 8)) + ((((int)threadIdx.x) & 3) * 2)) + vec_s_1)])) {
            condval_1 = acc_s[((i_17 * 2) + vec_s_1)];
          } else {
            condval_1 = 0x0p+0f/*0.000000e+00*/;
          }
          acc_s[((i_17 * 2) + vec_s_1)] = condval_1;
        }
      }
      tl::__sync_thread_partial<3, 128>();
      #pragma unroll
      for (int i_18 = 0; i_18 < 4; ++i_18) {
        sumexp_i[i_18] = 0x0p+0f/*0.000000e+00*/;
        #pragma unroll
        for (int rv_1 = 0; rv_1 < 8; ++rv_1) {
          sumexp_i[i_18] = (sumexp_i[i_18] + acc_s[(((((i_18 >> 1) * 16) + ((rv_1 & 3) * 4)) + ((i_18 & 1) * 2)) + (rv_1 >> 2))]);
        }
        sumexp_i[i_18] = tl::AllReduce<tl::SumOp, 128, 64, 0, 128>::run_hopper(sumexp_i[i_18], (&(((float*)buf_dyn_shmem)[55296])));
        sumexp_i[i_18] = tl::AllReduce<tl::SumOp, 4, 1, 0, 128>::run_hopper(sumexp_i[i_18]);
      }
      #pragma unroll
      for (int i_19 = 0; i_19 < 4; ++i_19) {
        sumexp[i_19] = ((sumexp[i_19] * exp2f(((m_i_prev[i_19] - m_i[i_19]) * 0x1.ec709dbe8903ep-5f/*6.011229e-02*/))) + sumexp_i[i_19]);
      }
      bar_k_0_free[0].arrive();
      bar_k_1_ready[0].wait((i_i & 1));
      #pragma unroll
      for (int i_20 = 0; i_20 < 16; ++i_20) {
        for (int vec_s_2 = 0; vec_s_2 < 2; ++vec_s_2) {
          float condval_2;
          if (((bool)is_k_valid_1[(((((((int)threadIdx.x) >> 6) * 32) + (((i_20 & 7) >> 1) * 8)) + ((((int)threadIdx.x) & 3) * 2)) + vec_s_2)])) {
            condval_2 = 0x0p+0f/*0.000000e+00*/;
          } else {
            condval_2 = -CUDART_INF_F;
          }
          acc_s[((i_20 * 2) + vec_s_2)] = condval_2;
        }
      }
      for (int ki_3 = 0; ki_3 < 16; ++ki_3) {
        for (int i_21 = 0; i_21 < 2; ++i_21) {
          tl::ptx_ldmatrix_x4((&(((bfloat16_t*)buf_dyn_shmem)[((((((ki_3 >> 2) * 4096) + (((((int)threadIdx.x) & 63) >> 5) * 2048)) + (i_21 * 1024)) + (((((int)threadIdx.x) & 15) >> 3) * 512)) + ((((((((int)threadIdx.x) & 15) * 64) + (((((((int)threadIdx.x) & 7) >> 2) + ((ki_3 & 3) >> 1)) & 1) * 32)) + (((((((int)threadIdx.x) & 3) >> 1) + (ki_3 & 1)) & 1) * 16)) + (((((((int)threadIdx.x) & 31) >> 4) + (((int)threadIdx.x) & 1)) & 1) * 8)) & 511))])) + 0, A_local_3 + (i_21 * 8));
        }
        for (int i_22 = 0; i_22 < 2; ++i_22) {
          tl::ptx_ldmatrix_x4((&(((bfloat16_t*)buf_dyn_shmem)[((((((((((ki_3 >> 2) * 4096) + ((((int)threadIdx.x) >> 6) * 2048)) + (i_22 * 1024)) + (((((int)threadIdx.x) & 31) >> 4) * 512)) + ((((int)threadIdx.x) & 7) * 64)) + (((((((int)threadIdx.x) & 7) >> 2) + ((ki_3 & 3) >> 1)) & 1) * 32)) + (((((((int)threadIdx.x) & 3) >> 1) + (ki_3 & 1)) & 1) * 16)) + (((((((int)threadIdx.x) & 15) >> 3) + (((int)threadIdx.x) & 1)) & 1) * 8)) + 69632)])) + 0, B_local_3 + (i_22 * 8));
        }
        for (int i_23 = 0; i_23 < 2; ++i_23) {
          for (int j_3 = 0; j_3 < 2; ++j_3) {
            tl::mma_sync<tl::DataType::kBFloat16, tl::DataType::kBFloat16, tl::DataType::kFloat32, 16, 8, 16, false, true>(reinterpret_cast<float*>(acc_s + ((i_23 * 16) + (j_3 * 8))), reinterpret_cast<const unsigned*>(A_local_3 + (i_23 * 8)), reinterpret_cast<const unsigned*>(B_local_3 + (j_3 * 8)));
            tl::mma_sync<tl::DataType::kBFloat16, tl::DataType::kBFloat16, tl::DataType::kFloat32, 16, 8, 16, false, true>(reinterpret_cast<float*>(acc_s + (((i_23 * 16) + (j_3 * 8)) + 4)), reinterpret_cast<const unsigned*>(A_local_3 + (i_23 * 8)), reinterpret_cast<const unsigned*>(B_local_3 + ((j_3 * 8) + 4)));
          }
        }
      }
      for (int ki_4 = 0; ki_4 < 16; ++ki_4) {
        for (int i_24 = 0; i_24 < 2; ++i_24) {
          tl::ptx_ldmatrix_x4((&(((bfloat16_t*)buf_dyn_shmem)[(((((((ki_4 >> 2) * 4096) + (((((int)threadIdx.x) & 63) >> 5) * 2048)) + (i_24 * 1024)) + (((((int)threadIdx.x) & 15) >> 3) * 512)) + ((((((((int)threadIdx.x) & 15) * 64) + (((((((int)threadIdx.x) & 7) >> 2) + ((ki_4 & 3) >> 1)) & 1) * 32)) + (((((((int)threadIdx.x) & 3) >> 1) + (ki_4 & 1)) & 1) * 16)) + (((((((int)threadIdx.x) & 31) >> 4) + (((int)threadIdx.x) & 1)) & 1) * 8)) & 511)) + 16384)])) + 0, A_local_4 + (i_24 * 8));
        }
        for (int i_25 = 0; i_25 < 2; ++i_25) {
          tl::ptx_ldmatrix_x4((&(((bfloat16_t*)buf_dyn_shmem)[((((((((((ki_4 >> 2) * 4096) + ((((int)threadIdx.x) >> 6) * 2048)) + (i_25 * 1024)) + (((((int)threadIdx.x) & 31) >> 4) * 512)) + ((((int)threadIdx.x) & 7) * 64)) + (((((((int)threadIdx.x) & 7) >> 2) + ((ki_4 & 3) >> 1)) & 1) * 32)) + (((((((int)threadIdx.x) & 3) >> 1) + (ki_4 & 1)) & 1) * 16)) + (((((((int)threadIdx.x) & 15) >> 3) + (((int)threadIdx.x) & 1)) & 1) * 8)) + 36864)])) + 0, B_local_4 + (i_25 * 8));
        }
        for (int i_26 = 0; i_26 < 2; ++i_26) {
          for (int j_4 = 0; j_4 < 2; ++j_4) {
            tl::mma_sync<tl::DataType::kBFloat16, tl::DataType::kBFloat16, tl::DataType::kFloat32, 16, 8, 16, false, true>(reinterpret_cast<float*>(acc_s + ((i_26 * 16) + (j_4 * 8))), reinterpret_cast<const unsigned*>(A_local_4 + (i_26 * 8)), reinterpret_cast<const unsigned*>(B_local_4 + (j_4 * 8)));
            tl::mma_sync<tl::DataType::kBFloat16, tl::DataType::kBFloat16, tl::DataType::kFloat32, 16, 8, 16, false, true>(reinterpret_cast<float*>(acc_s + (((i_26 * 16) + (j_4 * 8)) + 4)), reinterpret_cast<const unsigned*>(A_local_4 + (i_26 * 8)), reinterpret_cast<const unsigned*>(B_local_4 + ((j_4 * 8) + 4)));
          }
        }
      }
      for (int ki_5 = 0; ki_5 < 4; ++ki_5) {
        for (int i_27 = 0; i_27 < 2; ++i_27) {
          tl::ptx_ldmatrix_x4((&(((bfloat16_t*)buf_dyn_shmem)[(((((((((int)threadIdx.x) & 63) >> 5) * 2048) + (i_27 * 1024)) + (((((int)threadIdx.x) & 15) >> 3) * 512)) + ((((((((int)threadIdx.x) & 15) * 64) + (((((((int)threadIdx.x) & 7) >> 2) + (ki_5 >> 1)) & 1) * 32)) + (((((((int)threadIdx.x) & 3) >> 1) + (ki_5 & 1)) & 1) * 16)) + (((((((int)threadIdx.x) & 31) >> 4) + (((int)threadIdx.x) & 1)) & 1) * 8)) & 511)) + 32768)])) + 0, A_local_5 + (i_27 * 8));
        }
        for (int i_28 = 0; i_28 < 2; ++i_28) {
          tl::ptx_ldmatrix_x4((&(((bfloat16_t*)buf_dyn_shmem)[(((((((((((int)threadIdx.x) >> 6) * 2048) + (i_28 * 1024)) + (((((int)threadIdx.x) & 31) >> 4) * 512)) + ((((int)threadIdx.x) & 7) * 64)) + (((((((int)threadIdx.x) & 7) >> 2) + (ki_5 >> 1)) & 1) * 32)) + (((((((int)threadIdx.x) & 3) >> 1) + (ki_5 & 1)) & 1) * 16)) + (((((((int)threadIdx.x) & 15) >> 3) + (((int)threadIdx.x) & 1)) & 1) * 8)) + 106496)])) + 0, B_local_5 + (i_28 * 8));
        }
        for (int i_29 = 0; i_29 < 2; ++i_29) {
          for (int j_5 = 0; j_5 < 2; ++j_5) {
            tl::mma_sync<tl::DataType::kBFloat16, tl::DataType::kBFloat16, tl::DataType::kFloat32, 16, 8, 16, false, true>(reinterpret_cast<float*>(acc_s + ((i_29 * 16) + (j_5 * 8))), reinterpret_cast<const unsigned*>(A_local_5 + (i_29 * 8)), reinterpret_cast<const unsigned*>(B_local_5 + (j_5 * 8)));
            tl::mma_sync<tl::DataType::kBFloat16, tl::DataType::kBFloat16, tl::DataType::kFloat32, 16, 8, 16, false, true>(reinterpret_cast<float*>(acc_s + (((i_29 * 16) + (j_5 * 8)) + 4)), reinterpret_cast<const unsigned*>(A_local_5 + (i_29 * 8)), reinterpret_cast<const unsigned*>(B_local_5 + ((j_5 * 8) + 4)));
          }
        }
      }
      tl::wait_wgmma<0>();
      #pragma unroll
      for (int i_30 = 0; i_30 < 16; ++i_30) {
        float2 __2;
          float2 v__2 = *(float2*)(acc_s + (i_30 * 2));
          float2 v__3 = make_float2(0x1.ec709dbe8903ep-5f/*6.011229e-02*/, 0x1.ec709dbe8903ep-5f/*6.011229e-02*/);
          __2.x = (v__2.x*v__3.x);
          __2.y = (v__2.y*v__3.y);
        *(float2*)(QK_out + ((((((((((((int64_t)((int)blockIdx.x)) * (int64_t)131072) + (((((int64_t)((int)threadIdx.x)) & (int64_t)63) >> (int64_t)5) * (int64_t)65536)) + ((((int64_t)i_30) >> (int64_t)3) * (int64_t)32768)) + ((((int64_t)i_30) & (int64_t)1) * (int64_t)16384)) + (((((int64_t)((int)threadIdx.x)) & (int64_t)31) >> (int64_t)2) * (int64_t)2048)) + (((int64_t)i_i) * (int64_t)128)) + ((((int64_t)((int)threadIdx.x)) >> (int64_t)6) * (int64_t)32)) + (((((int64_t)i_30) & (int64_t)7) >> (int64_t)1) * (int64_t)8)) + ((((int64_t)((int)threadIdx.x)) & (int64_t)3) * (int64_t)2)) + (int64_t)64)) = __2;
      }
      #pragma unroll
      for (int i_31 = 0; i_31 < 4; ++i_31) {
        m_i_prev[i_31] = m_i[i_31];
      }
      tl::__sync_thread_partial<3, 128>();
      #pragma unroll
      for (int i_32 = 0; i_32 < 4; ++i_32) {
        #pragma unroll
        for (int rv_2 = 0; rv_2 < 8; ++rv_2) {
          m_i[i_32] = max(m_i[i_32], acc_s[(((((i_32 >> 1) * 16) + ((rv_2 & 3) * 4)) + ((i_32 & 1) * 2)) + (rv_2 >> 2))]);
        }
        m_i[i_32] = tl::AllReduce<tl::MaxOp, 128, 64, 0, 128>::run_hopper(m_i[i_32], (&(((float*)buf_dyn_shmem)[55680])));
        m_i[i_32] = tl::AllReduce<tl::MaxOp, 4, 1, 0, 128>::run_hopper(m_i[i_32]);
      }
      #pragma unroll
      for (int i_33 = 0; i_33 < 4; ++i_33) {
        m_i[i_33] = max(m_i[i_33], m_i_prev[i_33]);
      }
      #pragma unroll
      for (int i_34 = 0; i_34 < 32; ++i_34) {
        acc_s[i_34] = exp2f(((acc_s[i_34] * 0x1.ec709dbe8903ep-5f/*6.011229e-02*/) - (m_i[(((i_34 >> 4) * 2) + ((i_34 & 3) >> 1))] * 0x1.ec709dbe8903ep-5f/*6.011229e-02*/)));
      }
      #pragma unroll
      for (int i_35 = 0; i_35 < 16; ++i_35) {
        for (int vec_s_3 = 0; vec_s_3 < 2; ++vec_s_3) {
          float condval_3;
          if (((bool)is_k_valid_1[(((((((int)threadIdx.x) >> 6) * 32) + (((i_35 & 7) >> 1) * 8)) + ((((int)threadIdx.x) & 3) * 2)) + vec_s_3)])) {
            condval_3 = acc_s[((i_35 * 2) + vec_s_3)];
          } else {
            condval_3 = 0x0p+0f/*0.000000e+00*/;
          }
          acc_s[((i_35 * 2) + vec_s_3)] = condval_3;
        }
      }
      tl::__sync_thread_partial<3, 128>();
      #pragma unroll
      for (int i_36 = 0; i_36 < 4; ++i_36) {
        sumexp_i[i_36] = 0x0p+0f/*0.000000e+00*/;
        #pragma unroll
        for (int rv_3 = 0; rv_3 < 8; ++rv_3) {
          sumexp_i[i_36] = (sumexp_i[i_36] + acc_s[(((((i_36 >> 1) * 16) + ((rv_3 & 3) * 4)) + ((i_36 & 1) * 2)) + (rv_3 >> 2))]);
        }
        sumexp_i[i_36] = tl::AllReduce<tl::SumOp, 128, 64, 0, 128>::run_hopper(sumexp_i[i_36], (&(((float*)buf_dyn_shmem)[55552])));
        sumexp_i[i_36] = tl::AllReduce<tl::SumOp, 4, 1, 0, 128>::run_hopper(sumexp_i[i_36]);
      }
      #pragma unroll
      for (int i_37 = 0; i_37 < 4; ++i_37) {
        sumexp[i_37] = ((sumexp[i_37] * exp2f(((m_i_prev[i_37] - m_i[i_37]) * 0x1.ec709dbe8903ep-5f/*6.011229e-02*/))) + sumexp_i[i_37]);
      }
      bar_k_1_free[0].arrive();
    }
    if ((((((int)threadIdx.x) & 3) * 2) + (((int)threadIdx.x) >> 6)) == 0) {
      #pragma unroll
      for (int i_38 = 0; i_38 < 4; ++i_38) {
        M_out[((((((int)blockIdx.x) * 64) + (((((int)threadIdx.x) & 63) >> 5) * 32)) + (i_38 * 8)) + ((((int)threadIdx.x) & 31) >> 2))] = m_i[i_38];
        L_out[((((((int)blockIdx.x) * 64) + (((((int)threadIdx.x) & 63) >> 5) * 32)) + (i_38 * 8)) + ((((int)threadIdx.x) & 31) >> 2))] = sumexp[i_38];
      }
    }
  } else {
    tl::warpgroup_reg_dealloc<80>();
    for (int i_i_1 = 0; i_i_1 < 16; ++i_i_1) {
      bar_k_0_free[0].wait(((i_i_1 & 1) ^ 1));
      for (int r = 0; r < 4; ++r) {
        indices_local[0] = Indices[((((((((int)blockIdx.x) >> 1) * 2048) + (i_i_1 * 128)) + (r * 16)) + (((int)threadIdx.x) >> 3)) - 16)];
        is_k_valid_0[(((r * 16) + (((int)threadIdx.x) >> 3)) - 16)] = ((signed char)(indices_local[0] <= q_i));
        if ((bool)is_k_valid_0[(((r * 16) + (((int)threadIdx.x) >> 3)) - 16)]) {
          for (int u = 0; u < 4; ++u) {
            tl::cp_async_gs_conditional<16>(buf_dyn_shmem+(((((((u * 8192) + (r * 2048)) + ((((int)threadIdx.x) >> 3) * 128)) + (((((((int)threadIdx.x) & 63) >> 5) + ((((int)threadIdx.x) & 7) >> 2)) & 1) * 64)) + (((((((int)threadIdx.x) & 31) >> 4) + ((((int)threadIdx.x) & 3) >> 1)) & 1) * 32)) + (((((((int)threadIdx.x) & 15) >> 3) + (((int)threadIdx.x) & 1)) & 1) * 16)) + 169984), K+(((((int64_t)indices_local[(int64_t)0]) * (int64_t)576) + (((int64_t)u) * (int64_t)64)) + ((((int64_t)((int)threadIdx.x)) & (int64_t)7) * (int64_t)8)), ((0 <= indices_local[0]) && (indices_local[0] < 131072)));
            tl::cp_async_gs_conditional<16>(buf_dyn_shmem+(((((((u * 8192) + (r * 2048)) + ((((int)threadIdx.x) >> 3) * 128)) + (((((((int)threadIdx.x) & 63) >> 5) + ((((int)threadIdx.x) & 7) >> 2)) & 1) * 64)) + (((((((int)threadIdx.x) & 31) >> 4) + ((((int)threadIdx.x) & 3) >> 1)) & 1) * 32)) + (((((((int)threadIdx.x) & 15) >> 3) + (((int)threadIdx.x) & 1)) & 1) * 16)) + 104448), K+((((((int64_t)indices_local[(int64_t)0]) * (int64_t)576) + (((int64_t)u) * (int64_t)64)) + ((((int64_t)((int)threadIdx.x)) & (int64_t)7) * (int64_t)8)) + (int64_t)256), ((0 <= indices_local[0]) && (indices_local[0] < 131072)));
          }
          tl::cp_async_gs_conditional<16>(buf_dyn_shmem+((((((r * 2048) + ((((int)threadIdx.x) >> 3) * 128)) + (((((((int)threadIdx.x) & 63) >> 5) + ((((int)threadIdx.x) & 7) >> 2)) & 1) * 64)) + (((((((int)threadIdx.x) & 31) >> 4) + ((((int)threadIdx.x) & 3) >> 1)) & 1) * 32)) + (((((((int)threadIdx.x) & 15) >> 3) + (((int)threadIdx.x) & 1)) & 1) * 16)) + 202752), K+(((((int64_t)indices_local[(int64_t)0]) * (int64_t)576) + ((((int64_t)((int)threadIdx.x)) & (int64_t)7) * (int64_t)8)) + (int64_t)512), ((0 <= indices_local[0]) && (indices_local[0] < 131072)));
        }
      }
      tl::fence_proxy_async();
      tl::mbarrier_cp_async_arrive_noinc(bar_k_0_ready[0]);
      bar_k_1_free[0].wait(((i_i_1 & 1) ^ 1));
      for (int r_1 = 0; r_1 < 4; ++r_1) {
        indices_local[0] = Indices[((((((((int)blockIdx.x) >> 1) * 2048) + (i_i_1 * 128)) + (r_1 * 16)) + (((int)threadIdx.x) >> 3)) + 48)];
        is_k_valid_1[(((r_1 * 16) + (((int)threadIdx.x) >> 3)) - 16)] = ((signed char)(indices_local[0] <= q_i));
        if ((bool)is_k_valid_1[(((r_1 * 16) + (((int)threadIdx.x) >> 3)) - 16)]) {
          for (int u_1 = 0; u_1 < 4; ++u_1) {
            tl::cp_async_gs_conditional<16>(buf_dyn_shmem+(((((((u_1 * 8192) + (r_1 * 2048)) + ((((int)threadIdx.x) >> 3) * 128)) + (((((((int)threadIdx.x) & 63) >> 5) + ((((int)threadIdx.x) & 7) >> 2)) & 1) * 64)) + (((((((int)threadIdx.x) & 31) >> 4) + ((((int)threadIdx.x) & 3) >> 1)) & 1) * 32)) + (((((((int)threadIdx.x) & 15) >> 3) + (((int)threadIdx.x) & 1)) & 1) * 16)) + 137216), K+(((((int64_t)indices_local[(int64_t)0]) * (int64_t)576) + (((int64_t)u_1) * (int64_t)64)) + ((((int64_t)((int)threadIdx.x)) & (int64_t)7) * (int64_t)8)), ((0 <= indices_local[0]) && (indices_local[0] < 131072)));
            tl::cp_async_gs_conditional<16>(buf_dyn_shmem+(((((((u_1 * 8192) + (r_1 * 2048)) + ((((int)threadIdx.x) >> 3) * 128)) + (((((((int)threadIdx.x) & 63) >> 5) + ((((int)threadIdx.x) & 7) >> 2)) & 1) * 64)) + (((((((int)threadIdx.x) & 31) >> 4) + ((((int)threadIdx.x) & 3) >> 1)) & 1) * 32)) + (((((((int)threadIdx.x) & 15) >> 3) + (((int)threadIdx.x) & 1)) & 1) * 16)) + 71680), K+((((((int64_t)indices_local[(int64_t)0]) * (int64_t)576) + (((int64_t)u_1) * (int64_t)64)) + ((((int64_t)((int)threadIdx.x)) & (int64_t)7) * (int64_t)8)) + (int64_t)256), ((0 <= indices_local[0]) && (indices_local[0] < 131072)));
          }
          tl::cp_async_gs_conditional<16>(buf_dyn_shmem+((((((r_1 * 2048) + ((((int)threadIdx.x) >> 3) * 128)) + (((((((int)threadIdx.x) & 63) >> 5) + ((((int)threadIdx.x) & 7) >> 2)) & 1) * 64)) + (((((((int)threadIdx.x) & 31) >> 4) + ((((int)threadIdx.x) & 3) >> 1)) & 1) * 32)) + (((((((int)threadIdx.x) & 15) >> 3) + (((int)threadIdx.x) & 1)) & 1) * 16)) + 210944), K+(((((int64_t)indices_local[(int64_t)0]) * (int64_t)576) + ((((int64_t)((int)threadIdx.x)) & (int64_t)7) * (int64_t)8)) + (int64_t)512), ((0 <= indices_local[0]) && (indices_local[0] < 131072)));
        }
      }
      tl::fence_proxy_async();
      tl::mbarrier_cp_async_arrive_noinc(bar_k_1_ready[0]);
    }
  }
}


Compilation error:
/usr/local/lib/python3.12/dist-packages/tilelang/3rdparty/../src/tl_templates/cuda/instruction/../atomic.h(350): warning #549-D: variable "ret_val_x" is used before its value is set
          *reinterpret_cast<unsigned short *>(&ret_val_x);
                                               ^

Remark: The warnings can be suppressed with "-diag-suppress <warning-number>"

/usr/local/lib/python3.12/dist-packages/tilelang/3rdparty/../src/tl_templates/cuda/instruction/../atomic.h(352): warning #549-D: variable "ret_val_y" is used before its value is set
          *reinterpret_cast<unsigned short *>(&ret_val_y);
                                               ^

/usr/local/lib/python3.12/dist-packages/tilelang/3rdparty/../src/tl_templates/cuda/instruction/../atomic.h(349): warning #550-D: variable "ret_val_x_cast" was set but never used
      unsigned short ret_val_x_cast =
                     ^

/usr/local/lib/python3.12/dist-packages/tilelang/3rdparty/../src/tl_templates/cuda/instruction/../atomic.h(351): warning #550-D: variable "ret_val_y_cast" was set but never used
      unsigned short ret_val_y_cast =
                     ^

/usr/local/lib/python3.12/dist-packages/tilelang/3rdparty/../src/tl_templates/cuda/instruction/../atomic.h(392): warning #549-D: variable "ret_val_x" is used before its value is set
          *reinterpret_cast<unsigned short *>(&ret_val_x);
                                               ^

/usr/local/lib/python3.12/dist-packages/tilelang/3rdparty/../src/tl_templates/cuda/instruction/../atomic.h(394): warning #549-D: variable "ret_val_y" is used before its value is set
          *reinterpret_cast<unsigned short *>(&ret_val_y);
                                               ^

/usr/local/lib/python3.12/dist-packages/tilelang/3rdparty/../src/tl_templates/cuda/instruction/../atomic.h(437): warning #549-D: variable "ret_val" is used before its value is set
          *reinterpret_cast<unsigned short *>(&ret_val.x);
                                               ^

/usr/local/lib/python3.12/dist-packages/tilelang/3rdparty/../src/tl_templates/cuda/instruction/../atomic.h(436): warning #550-D: variable "ret_val_x_cast" was set but never used
      unsigned short ret_val_x_cast =
                     ^

/usr/local/lib/python3.12/dist-packages/tilelang/3rdparty/../src/tl_templates/cuda/instruction/../atomic.h(438): warning #550-D: variable "ret_val_y_cast" was set but never used
      unsigned short ret_val_y_cast =
                     ^

/usr/local/lib/python3.12/dist-packages/tilelang/3rdparty/../src/tl_templates/cuda/instruction/../atomic.h(477): warning #549-D: variable "ret_val" is used before its value is set
          *reinterpret_cast<unsigned short *>(&ret_val.x);
                                               ^

/usr/local/lib/python3.12/dist-packages/tilelang/3rdparty/../src/tl_templates/cuda/instruction/../atomic.h(513): warning #550-D: variable "ret_val" was set but never used
      float2 ret_val;
             ^

/usr/local/lib/python3.12/dist-packages/tilelang/3rdparty/../src/tl_templates/cuda/instruction/../atomic.h(578): warning #550-D: variable "ret_val" was set but never used
      float4 ret_val;
             ^

/usr/local/lib/python3.12/dist-packages/tilelang/3rdparty/../src/tl_templates/cuda/instruction/../common.h(507): warning #20012-D: __device__ annotation is ignored on a function("float_e4m3_t") that is explicitly defaulted on its first declaration
    __inline__ __attribute__((always_inline)) __attribute__((device)) __attribute__((host))
                                                             ^

/usr/local/lib/python3.12/dist-packages/tilelang/3rdparty/../src/tl_templates/cuda/instruction/../common.h(507): warning #20012-D: __host__ annotation is ignored on a function("float_e4m3_t") that is explicitly defaulted on its first declaration
    __inline__ __attribute__((always_inline)) __attribute__((device)) __attribute__((host))
                                                                                     ^

/usr/local/lib/python3.12/dist-packages/tilelang/3rdparty/../src/tl_templates/cuda/instruction/../common.h(517): warning #20012-D: __device__ annotation is ignored on a function("float_e5m2_t") that is explicitly defaulted on its first declaration
    __inline__ __attribute__((always_inline)) __attribute__((device)) __attribute__((host))
                                                             ^

/usr/local/lib/python3.12/dist-packages/tilelang/3rdparty/../src/tl_templates/cuda/instruction/../common.h(517): warning #20012-D: __host__ annotation is ignored on a function("float_e5m2_t") that is explicitly defaulted on its first declaration
    __inline__ __attribute__((always_inline)) __attribute__((device)) __attribute__((host))
                                                                                     ^

/tmp/tmpxy0bilja/tvm_kernels.cu(145): error: namespace "tl" has no member "wait_wgmma"
        tl::wait_wgmma<0>();
            ^

/tmp/tmpxy0bilja/tvm_kernels.cu(145): error: expected an expression
        tl::wait_wgmma<0>();
                          ^

/tmp/tmpxy0bilja/tvm_kernels.cu(150): warning #1046-D: floating-point value cannot be represented exactly
            float2 v__1 = make_float2(0x1.ec709dbe8903ep-5f , 0x1.ec709dbe8903ep-5f );
                                      ^

/tmp/tmpxy0bilja/tvm_kernels.cu(150): warning #1046-D: floating-point value cannot be represented exactly
            float2 v__1 = make_float2(0x1.ec709dbe8903ep-5f , 0x1.ec709dbe8903ep-5f );
                                                              ^

/tmp/tmpxy0bilja/tvm_kernels.cu(175): warning #1046-D: floating-point value cannot be represented exactly
          acc_s[i_16] = exp2f(((acc_s[i_16] * 0x1.ec709dbe8903ep-5f ) - (m_i[(((i_16 >> 4) * 2) + ((i_16 & 3) >> 1))] * 0x1.ec709dbe8903ep-5f )));
                                              ^

/tmp/tmpxy0bilja/tvm_kernels.cu(175): warning #1046-D: floating-point value cannot be represented exactly
          acc_s[i_16] = exp2f(((acc_s[i_16] * 0x1.ec709dbe8903ep-5f ) - (m_i[(((i_16 >> 4) * 2) + ((i_16 & 3) >> 1))] * 0x1.ec709dbe8903ep-5f )));
                                                                                                                        ^

/tmp/tmpxy0bilja/tvm_kernels.cu(202): warning #1046-D: floating-point value cannot be represented exactly
          sumexp[i_19] = ((sumexp[i_19] * exp2f(((m_i_prev[i_19] - m_i[i_19]) * 0x1.ec709dbe8903ep-5f ))) + sumexp_i[i_19]);
                                                                                ^

/tmp/tmpxy0bilja/tvm_kernels.cu(260): error: namespace "tl" has no member "wait_wgmma"
        tl::wait_wgmma<0>();
            ^

/tmp/tmpxy0bilja/tvm_kernels.cu(260): error: expected an expression
        tl::wait_wgmma<0>();
                          ^

/tmp/tmpxy0bilja/tvm_kernels.cu(265): warning #1046-D: floating-point value cannot be represented exactly
            float2 v__3 = make_float2(0x1.ec709dbe8903ep-5f , 0x1.ec709dbe8903ep-5f );
                                      ^

/tmp/tmpxy0bilja/tvm_kernels.cu(265): warning #1046-D: floating-point value cannot be represented exactly
            float2 v__3 = make_float2(0x1.ec709dbe8903ep-5f , 0x1.ec709dbe8903ep-5f );
                                                              ^

/tmp/tmpxy0bilja/tvm_kernels.cu(290): warning #1046-D: floating-point value cannot be represented exactly
          acc_s[i_34] = exp2f(((acc_s[i_34] * 0x1.ec709dbe8903ep-5f ) - (m_i[(((i_34 >> 4) * 2) + ((i_34 & 3) >> 1))] * 0x1.ec709dbe8903ep-5f )));
                                              ^

/tmp/tmpxy0bilja/tvm_kernels.cu(290): warning #1046-D: floating-point value cannot be represented exactly
          acc_s[i_34] = exp2f(((acc_s[i_34] * 0x1.ec709dbe8903ep-5f ) - (m_i[(((i_34 >> 4) * 2) + ((i_34 & 3) >> 1))] * 0x1.ec709dbe8903ep-5f )));
                                                                                                                        ^

/tmp/tmpxy0bilja/tvm_kernels.cu(317): warning #1046-D: floating-point value cannot be represented exactly
          sumexp[i_37] = ((sumexp[i_37] * exp2f(((m_i_prev[i_37] - m_i[i_37]) * 0x1.ec709dbe8903ep-5f ))) + sumexp_i[i_37]);
                                                                                ^

/usr/local/lib/python3.12/dist-packages/tilelang/3rdparty/../src/tl_templates/cuda/intrin.h(116): warning #179-D: right operand of "%" is zero
                           (thread_extent / 32),
                           ^
          detected during instantiation of "__nv_bool tl::tl_shuffle_elect<thread_extent>() [with thread_extent=0]" at line 46 of /tmp/tmpxy0bilja/tvm_kernels.cu

4 errors detected in the compilation of "/tmp/tmpxy0bilja/tvm_kernels.cu".

Command: /usr/local/cuda/bin/nvcc --cubin -O3 -lineinfo -arch=sm_100a -std=c++17 -I/usr/local/lib/python3.12/dist-packages/tilelang/3rdparty/../src -I/usr/local/lib/python3.12/dist-packages/tilelang/3rdparty/cutlass/include -O3 -Wno-deprecated-declarations -U__CUDA_NO_HALF_OPERATORS__ -U__CUDA_NO_HALF_CONVERSIONS__ -U__CUDA_NO_HALF2_OPERATORS__ -U__CUDA_NO_BFLOAT16_CONVERSIONS__ --expt-relaxed-constexpr --expt-extended-lambda --ptxas-options=-v,--register-usage-level=10 -DNDEBUG -o /tmp/tmpxy0bilja/tvm_kernels.cubin /tmp/tmpxy0bilja/tvm_kernels.cu
